# A8 Card Sorting

Your readme should include the following information. Each student needs to submit all of this information themselves, even when pair programming. 

## General Information
Programming Partner Name (if you'd like to be graded together):

Other Collaborators (and kudos to helpful members of the class):

Any references used besides JavaDoc and course materials:

## Assignment Reflection

What did you notice about the differences in runtime across algorithms as you changed the number of cards you were sorting? If you had to split them into "slower" algorithms vs "faster" algorithms, which would you put in each category?

Victoria Reyes Borges - For the smaller piles, the algorithms seemed to go finished quickly but when there were bigger piles, they got slower. Selection adn insertion sort were slower (O(n^2)), while Quicksort and merge sort were faster (O(n log n)).

Kiara Sunil Singh - I noticed that the system runtime for merge sort was constant and quick regardless of the number of cards that we used. This makes logical sense since merge sorts has a dependable time complexity of O(nlogn). However, when I ran insertion sort and selection sort I noticed that as the number of cards in the cardpile increased its system runtime also increased, this is consistent with its time complexity since selection sort's average case is O(n^2) and insertion sort's average case is O(n^2). Additionallly, I found that quicksort also had one of the quicker system runtimes.

Please reflect on your experience with this assignment. What was most challenging? What was most interesting?

Victoria Reyes Borges - I enjoyed this aissgnment, mostlye because I like the concepts of the sorting algorithms and the different ways we can use them. I found challeging visually the algortihms mentally or without any physcial objects, so I had to use some of my personal things to figure out the logic! I found interesting how, in a way, we can "make" storage in coding but when we perform these sorting algortihms that storage is just space "in real life", so definitely tying that back what I was doing with physically visualizing my algorithm into code was interesting!

Kiara Sunil Singh - I really enjoyed this assignment because I liked working with real world algorithms and being able to apply previous knowledge to a well known concept. I found this to be very helpful in understanding more about how queues work and the logical sequence of a queue's features. I also enjoyed looking at the different runtimes of each algorithm because it helped me better understand the efficiency of each algorithm and see firsthand how bigger passed in arguments can affect the runtime. 